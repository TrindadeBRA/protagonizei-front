/**
 * Generated by orval v7.6.0 ðŸº
 * Do not edit manually.
 * TrinityKitWP API
 * API para gerenciamento de posts, pedidos personalizados e formulÃ¡rios de contato no WordPress
 * OpenAPI spec version: 1.0.0
 */
import type {
  GetConfigs200,
  GetConfigs401,
  GetOrdersBookDetails200,
  GetOrdersBookDetails404,
  GetOrdersBookDetails500,
  GetOrdersCheckCoupon200,
  GetOrdersCheckCoupon400,
  GetOrdersCheckCoupon404,
  GetOrdersCheckCouponParams,
  GetOrdersOrderIdPaymentStatus200,
  GetOrdersOrderIdPaymentStatus404,
  GetPostSlug200,
  GetPostSlug400,
  GetPostSlug401,
  GetPostSlug404,
  GetPostSlugs200,
  GetPostSlugs401,
  GetPostSlugsParams,
  GetWebhookCheckFaceswap200,
  GetWebhookCheckFaceswap500,
  GetWebhookDeliverPdf200,
  GetWebhookDeliverPdf500,
  GetWebhookGeneratePdf200,
  GetWebhookGeneratePdf500,
  GetWebhookGenerateTextAssets200,
  GetWebhookGenerateTextAssets500,
  GetWebhookInitiateFaceswap200,
  GetWebhookInitiateFaceswap500,
  GetWebhookMergeAssets200,
  GetWebhookMergeAssets500,
  GetWebhookSendThanks200,
  GetWebhookSendThanks500,
  PostContactFormSubmit200,
  PostContactFormSubmit400,
  PostContactFormSubmit401,
  PostContactFormSubmit500,
  PostContactFormSubmitBody,
  PostOrders201,
  PostOrders400,
  PostOrders401,
  PostOrders500,
  PostOrdersBody,
  PostOrdersOrderIdPix200,
  PostOrdersOrderIdPix500,
  PostWebhookPaymentConfirm200,
  PostWebhookPaymentConfirm400,
  PostWebhookPaymentConfirm404,
  PostWebhookPaymentConfirmBody
} from './model';

/**
 * Retorna as configuraÃ§Ãµes bÃ¡sicas do site WordPress
 * @summary Obter configuraÃ§Ãµes do site
 */
export type getConfigsResponse200 = {
  data: GetConfigs200
  status: 200
}

export type getConfigsResponse401 = {
  data: GetConfigs401
  status: 401
}
    
export type getConfigsResponseComposite = getConfigsResponse200 | getConfigsResponse401;
    
export type getConfigsResponse = getConfigsResponseComposite & {
  headers: Headers;
}

export const getGetConfigsUrl = () => {


  

  return `/configs`
}

export const getConfigs = async ( options?: RequestInit): Promise<getConfigsResponse> => {
  
  const res = await fetch(getGetConfigsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getConfigsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getConfigsResponse
}



/**
 * Cria um novo registro de contato no WordPress com suporte para upload de arquivos. Todos os campos sÃ£o obrigatÃ³rios exceto o arquivo anexo.
 * @summary Enviar formulÃ¡rio de contato
 */
export type postContactFormSubmitResponse200 = {
  data: PostContactFormSubmit200
  status: 200
}

export type postContactFormSubmitResponse400 = {
  data: PostContactFormSubmit400
  status: 400
}

export type postContactFormSubmitResponse401 = {
  data: PostContactFormSubmit401
  status: 401
}

export type postContactFormSubmitResponse500 = {
  data: PostContactFormSubmit500
  status: 500
}
    
export type postContactFormSubmitResponseComposite = postContactFormSubmitResponse200 | postContactFormSubmitResponse400 | postContactFormSubmitResponse401 | postContactFormSubmitResponse500;
    
export type postContactFormSubmitResponse = postContactFormSubmitResponseComposite & {
  headers: Headers;
}

export const getPostContactFormSubmitUrl = () => {


  

  return `/contact-form/submit`
}

export const postContactFormSubmit = async (postContactFormSubmitBody: PostContactFormSubmitBody, options?: RequestInit): Promise<postContactFormSubmitResponse> => {
    const formData = new FormData();
formData.append('name', postContactFormSubmitBody.name)
formData.append('email', postContactFormSubmitBody.email)
formData.append('phone', postContactFormSubmitBody.phone)
if(postContactFormSubmitBody.linkedin !== undefined) {
 formData.append('linkedin', postContactFormSubmitBody.linkedin)
 }
formData.append('message', postContactFormSubmitBody.message)
formData.append('tag', postContactFormSubmitBody.tag)
if(postContactFormSubmitBody.attachment !== undefined) {
 formData.append('attachment', postContactFormSubmitBody.attachment)
 }

  const res = await fetch(getPostContactFormSubmitUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postContactFormSubmitResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postContactFormSubmitResponse
}



/**
 * Retorna uma lista de posts publicados com seus detalhes. Pode ser limitado por quantidade ou paginado.
 * @summary Listar posts
 */
export type getPostSlugsResponse200 = {
  data: GetPostSlugs200
  status: 200
}

export type getPostSlugsResponse401 = {
  data: GetPostSlugs401
  status: 401
}
    
export type getPostSlugsResponseComposite = getPostSlugsResponse200 | getPostSlugsResponse401;
    
export type getPostSlugsResponse = getPostSlugsResponseComposite & {
  headers: Headers;
}

export const getGetPostSlugsUrl = (params?: GetPostSlugsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/post-slugs?${stringifiedParams}` : `/post-slugs`
}

export const getPostSlugs = async (params?: GetPostSlugsParams, options?: RequestInit): Promise<getPostSlugsResponse> => {
  
  const res = await fetch(getGetPostSlugsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getPostSlugsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getPostSlugsResponse
}



/**
 * Retorna os detalhes de um post especÃ­fico usando seu slug
 * @summary Obter post por slug
 */
export type getPostSlugResponse200 = {
  data: GetPostSlug200
  status: 200
}

export type getPostSlugResponse400 = {
  data: GetPostSlug400
  status: 400
}

export type getPostSlugResponse401 = {
  data: GetPostSlug401
  status: 401
}

export type getPostSlugResponse404 = {
  data: GetPostSlug404
  status: 404
}
    
export type getPostSlugResponseComposite = getPostSlugResponse200 | getPostSlugResponse400 | getPostSlugResponse401 | getPostSlugResponse404;
    
export type getPostSlugResponse = getPostSlugResponseComposite & {
  headers: Headers;
}

export const getGetPostSlugUrl = (slug: string,) => {


  

  return `/post/${slug}`
}

export const getPostSlug = async (slug: string, options?: RequestInit): Promise<getPostSlugResponse> => {
  
  const res = await fetch(getGetPostSlugUrl(slug),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getPostSlugResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getPostSlugResponse
}



/**
 * Cria um novo pedido personalizado para uma crianÃ§a
 * @summary Criar novo pedido
 */
export type postOrdersResponse201 = {
  data: PostOrders201
  status: 201
}

export type postOrdersResponse400 = {
  data: PostOrders400
  status: 400
}

export type postOrdersResponse401 = {
  data: PostOrders401
  status: 401
}

export type postOrdersResponse500 = {
  data: PostOrders500
  status: 500
}
    
export type postOrdersResponseComposite = postOrdersResponse201 | postOrdersResponse400 | postOrdersResponse401 | postOrdersResponse500;
    
export type postOrdersResponse = postOrdersResponseComposite & {
  headers: Headers;
}

export const getPostOrdersUrl = () => {


  

  return `/orders`
}

export const postOrders = async (postOrdersBody: PostOrdersBody, options?: RequestInit): Promise<postOrdersResponse> => {
    const formData = new FormData();
if(postOrdersBody.coupon !== undefined) {
 formData.append('coupon', postOrdersBody.coupon)
 }
formData.append('childName', postOrdersBody.childName)
formData.append('childAge', postOrdersBody.childAge.toString())
formData.append('childGender', postOrdersBody.childGender)
formData.append('skinTone', postOrdersBody.skinTone)
formData.append('parentName', postOrdersBody.parentName)
formData.append('email', postOrdersBody.email)
formData.append('phone', postOrdersBody.phone)
formData.append('photo', postOrdersBody.photo)

  const res = await fetch(getPostOrdersUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postOrdersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postOrdersResponse
}



/**
 * Retorna informaÃ§Ãµes bÃ¡sicas do livro mais recente publicado no sistema, incluindo ID, nome e preÃ§o. Este endpoint nÃ£o requer autenticaÃ§Ã£o e busca automaticamente o livro mais recente baseado na data de publicaÃ§Ã£o.
 * @summary Obter detalhes do livro mais recente
 */
export type getOrdersBookDetailsResponse200 = {
  data: GetOrdersBookDetails200
  status: 200
}

export type getOrdersBookDetailsResponse404 = {
  data: GetOrdersBookDetails404
  status: 404
}

export type getOrdersBookDetailsResponse500 = {
  data: GetOrdersBookDetails500
  status: 500
}
    
export type getOrdersBookDetailsResponseComposite = getOrdersBookDetailsResponse200 | getOrdersBookDetailsResponse404 | getOrdersBookDetailsResponse500;
    
export type getOrdersBookDetailsResponse = getOrdersBookDetailsResponseComposite & {
  headers: Headers;
}

export const getGetOrdersBookDetailsUrl = () => {


  

  return `/orders/book-details`
}

export const getOrdersBookDetails = async ( options?: RequestInit): Promise<getOrdersBookDetailsResponse> => {
  
  const res = await fetch(getGetOrdersBookDetailsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOrdersBookDetailsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getOrdersBookDetailsResponse
}



/**
 * Cria um pagamento PIX para um pedido existente usando a API do Asaas
 * @summary Criar pagamento PIX para um pedido
 */
export type postOrdersOrderIdPixResponse200 = {
  data: PostOrdersOrderIdPix200
  status: 200
}

export type postOrdersOrderIdPixResponse500 = {
  data: PostOrdersOrderIdPix500
  status: 500
}
    
export type postOrdersOrderIdPixResponseComposite = postOrdersOrderIdPixResponse200 | postOrdersOrderIdPixResponse500;
    
export type postOrdersOrderIdPixResponse = postOrdersOrderIdPixResponseComposite & {
  headers: Headers;
}

export const getPostOrdersOrderIdPixUrl = (orderId: number,) => {


  

  return `/orders/${orderId}/pix`
}

export const postOrdersOrderIdPix = async (orderId: number, options?: RequestInit): Promise<postOrdersOrderIdPixResponse> => {
  
  const res = await fetch(getPostOrdersOrderIdPixUrl(orderId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postOrdersOrderIdPixResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postOrdersOrderIdPixResponse
}



/**
 * Valida um cupom para um pedido e retorna o preÃ§o atualizado
 * @summary Validar cupom e retornar preÃ§o atualizado
 */
export type getOrdersCheckCouponResponse200 = {
  data: GetOrdersCheckCoupon200
  status: 200
}

export type getOrdersCheckCouponResponse400 = {
  data: GetOrdersCheckCoupon400
  status: 400
}

export type getOrdersCheckCouponResponse404 = {
  data: GetOrdersCheckCoupon404
  status: 404
}
    
export type getOrdersCheckCouponResponseComposite = getOrdersCheckCouponResponse200 | getOrdersCheckCouponResponse400 | getOrdersCheckCouponResponse404;
    
export type getOrdersCheckCouponResponse = getOrdersCheckCouponResponseComposite & {
  headers: Headers;
}

export const getGetOrdersCheckCouponUrl = (params: GetOrdersCheckCouponParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orders/check-coupon?${stringifiedParams}` : `/orders/check-coupon`
}

export const getOrdersCheckCoupon = async (params: GetOrdersCheckCouponParams, options?: RequestInit): Promise<getOrdersCheckCouponResponse> => {
  
  const res = await fetch(getGetOrdersCheckCouponUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOrdersCheckCouponResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getOrdersCheckCouponResponse
}



/**
 * Endpoint para receber notificaÃ§Ãµes de confirmaÃ§Ã£o de pagamento do Asaas. Atualiza o status do pedido para pago e registra os dados da transaÃ§Ã£o.
 * @summary Webhook de confirmaÃ§Ã£o de pagamento
 */
export type postWebhookPaymentConfirmResponse200 = {
  data: PostWebhookPaymentConfirm200
  status: 200
}

export type postWebhookPaymentConfirmResponse400 = {
  data: PostWebhookPaymentConfirm400
  status: 400
}

export type postWebhookPaymentConfirmResponse404 = {
  data: PostWebhookPaymentConfirm404
  status: 404
}
    
export type postWebhookPaymentConfirmResponseComposite = postWebhookPaymentConfirmResponse200 | postWebhookPaymentConfirmResponse400 | postWebhookPaymentConfirmResponse404;
    
export type postWebhookPaymentConfirmResponse = postWebhookPaymentConfirmResponseComposite & {
  headers: Headers;
}

export const getPostWebhookPaymentConfirmUrl = () => {


  

  return `/webhook/payment-confirm`
}

export const postWebhookPaymentConfirm = async (postWebhookPaymentConfirmBody: PostWebhookPaymentConfirmBody, options?: RequestInit): Promise<postWebhookPaymentConfirmResponse> => {
  
  const res = await fetch(getPostWebhookPaymentConfirmUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postWebhookPaymentConfirmBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postWebhookPaymentConfirmResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postWebhookPaymentConfirmResponse
}



/**
 * Verifica se um pedido especÃ­fico jÃ¡ foi pago
 * @summary Verificar status do pagamento
 */
export type getOrdersOrderIdPaymentStatusResponse200 = {
  data: GetOrdersOrderIdPaymentStatus200
  status: 200
}

export type getOrdersOrderIdPaymentStatusResponse404 = {
  data: GetOrdersOrderIdPaymentStatus404
  status: 404
}
    
export type getOrdersOrderIdPaymentStatusResponseComposite = getOrdersOrderIdPaymentStatusResponse200 | getOrdersOrderIdPaymentStatusResponse404;
    
export type getOrdersOrderIdPaymentStatusResponse = getOrdersOrderIdPaymentStatusResponseComposite & {
  headers: Headers;
}

export const getGetOrdersOrderIdPaymentStatusUrl = (orderId: number,) => {


  

  return `/orders/${orderId}/payment-status`
}

export const getOrdersOrderIdPaymentStatus = async (orderId: number, options?: RequestInit): Promise<getOrdersOrderIdPaymentStatusResponse> => {
  
  const res = await fetch(getGetOrdersOrderIdPaymentStatusUrl(orderId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOrdersOrderIdPaymentStatusResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getOrdersOrderIdPaymentStatusResponse
}



/**
 * Endpoint que verifica pedidos com status 'paid', envia emails de agradecimento e atualiza o status para 'thanked'
 * @summary Webhook para envio de emails de agradecimento
 */
export type getWebhookSendThanksResponse200 = {
  data: GetWebhookSendThanks200
  status: 200
}

export type getWebhookSendThanksResponse500 = {
  data: GetWebhookSendThanks500
  status: 500
}
    
export type getWebhookSendThanksResponseComposite = getWebhookSendThanksResponse200 | getWebhookSendThanksResponse500;
    
export type getWebhookSendThanksResponse = getWebhookSendThanksResponseComposite & {
  headers: Headers;
}

export const getGetWebhookSendThanksUrl = () => {


  

  return `/webhook/send-thanks`
}

export const getWebhookSendThanks = async ( options?: RequestInit): Promise<getWebhookSendThanksResponse> => {
  
  const res = await fetch(getGetWebhookSendThanksUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookSendThanksResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookSendThanksResponse
}



/**
 * Processa todos os pedidos no status 'thanked' para gerar textos personalizados usando Deepseek API
 * @summary Gerar textos personalizados em lote
 */
export type getWebhookGenerateTextAssetsResponse200 = {
  data: GetWebhookGenerateTextAssets200
  status: 200
}

export type getWebhookGenerateTextAssetsResponse500 = {
  data: GetWebhookGenerateTextAssets500
  status: 500
}
    
export type getWebhookGenerateTextAssetsResponseComposite = getWebhookGenerateTextAssetsResponse200 | getWebhookGenerateTextAssetsResponse500;
    
export type getWebhookGenerateTextAssetsResponse = getWebhookGenerateTextAssetsResponseComposite & {
  headers: Headers;
}

export const getGetWebhookGenerateTextAssetsUrl = () => {


  

  return `/webhook/generate-text-assets`
}

export const getWebhookGenerateTextAssets = async ( options?: RequestInit): Promise<getWebhookGenerateTextAssetsResponse> => {
  
  const res = await fetch(getGetWebhookGenerateTextAssetsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookGenerateTextAssetsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookGenerateTextAssetsResponse
}



/**
 * Processa todos os pedidos no status 'created_assets_text' que ainda nÃ£o tiveram o face swap iniciado. Para cada pÃ¡gina do livro, inicia o processo de face swap na API externa e salva os IDs das tarefas retornadas.
 * @summary Iniciar processo de face swap em lote
 */
export type getWebhookInitiateFaceswapResponse200 = {
  data: GetWebhookInitiateFaceswap200
  status: 200
}

export type getWebhookInitiateFaceswapResponse500 = {
  data: GetWebhookInitiateFaceswap500
  status: 500
}
    
export type getWebhookInitiateFaceswapResponseComposite = getWebhookInitiateFaceswapResponse200 | getWebhookInitiateFaceswapResponse500;
    
export type getWebhookInitiateFaceswapResponse = getWebhookInitiateFaceswapResponseComposite & {
  headers: Headers;
}

export const getGetWebhookInitiateFaceswapUrl = () => {


  

  return `/webhook/initiate-faceswap`
}

export const getWebhookInitiateFaceswap = async ( options?: RequestInit): Promise<getWebhookInitiateFaceswapResponse> => {
  
  const res = await fetch(getGetWebhookInitiateFaceswapUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookInitiateFaceswapResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookInitiateFaceswapResponse
}



/**
 * Processa todos os pedidos no status 'created_assets_text' que jÃ¡ tiveram o face swap iniciado (face_swap_initiated = true). Verifica o status das tarefas na API externa e processa as imagens que estÃ£o prontas, salvando-as no WordPress e atualizando o status do pedido quando todas as pÃ¡ginas estiverem concluÃ­das.
 * @summary Verificar status do face swap e processar imagens prontas
 */
export type getWebhookCheckFaceswapResponse200 = {
  data: GetWebhookCheckFaceswap200
  status: 200
}

export type getWebhookCheckFaceswapResponse500 = {
  data: GetWebhookCheckFaceswap500
  status: 500
}
    
export type getWebhookCheckFaceswapResponseComposite = getWebhookCheckFaceswapResponse200 | getWebhookCheckFaceswapResponse500;
    
export type getWebhookCheckFaceswapResponse = getWebhookCheckFaceswapResponseComposite & {
  headers: Headers;
}

export const getGetWebhookCheckFaceswapUrl = () => {


  

  return `/webhook/check-faceswap`
}

export const getWebhookCheckFaceswap = async ( options?: RequestInit): Promise<getWebhookCheckFaceswapResponse> => {
  
  const res = await fetch(getGetWebhookCheckFaceswapUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookCheckFaceswapResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookCheckFaceswapResponse
}



/**
 * Processa todos os pedidos no status 'created_assets_illustration' para combinar os textos personalizados com as ilustraÃ§Ãµes processadas. Gera as pÃ¡ginas finais do livro com texto sobreposto nas imagens na metade direita, usando fonte branca com sombra para boa legibilidade.
 * @summary Combinar textos e ilustraÃ§Ãµes em lote
 */
export type getWebhookMergeAssetsResponse200 = {
  data: GetWebhookMergeAssets200
  status: 200
}

export type getWebhookMergeAssetsResponse500 = {
  data: GetWebhookMergeAssets500
  status: 500
}
    
export type getWebhookMergeAssetsResponseComposite = getWebhookMergeAssetsResponse200 | getWebhookMergeAssetsResponse500;
    
export type getWebhookMergeAssetsResponse = getWebhookMergeAssetsResponseComposite & {
  headers: Headers;
}

export const getGetWebhookMergeAssetsUrl = () => {


  

  return `/webhook/merge-assets`
}

export const getWebhookMergeAssets = async ( options?: RequestInit): Promise<getWebhookMergeAssetsResponse> => {
  
  const res = await fetch(getGetWebhookMergeAssetsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookMergeAssetsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookMergeAssetsResponse
}



/**
 * Processa todos os pedidos no status 'created_assets_merge' para gerar PDFs completos dos livros personalizados. Coleta todas as imagens finais das pÃ¡ginas (final_page_with_text) e cria um PDF profissional com todas as pÃ¡ginas do livro na ordem correta. ApÃ³s a geraÃ§Ã£o bem-sucedida, atualiza o status do pedido para 'ready_for_delivery'.
 * @summary Gerar PDFs dos livros personalizados em lote
 */
export type getWebhookGeneratePdfResponse200 = {
  data: GetWebhookGeneratePdf200
  status: 200
}

export type getWebhookGeneratePdfResponse500 = {
  data: GetWebhookGeneratePdf500
  status: 500
}
    
export type getWebhookGeneratePdfResponseComposite = getWebhookGeneratePdfResponse200 | getWebhookGeneratePdfResponse500;
    
export type getWebhookGeneratePdfResponse = getWebhookGeneratePdfResponseComposite & {
  headers: Headers;
}

export const getGetWebhookGeneratePdfUrl = () => {


  

  return `/webhook/generate-pdf`
}

export const getWebhookGeneratePdf = async ( options?: RequestInit): Promise<getWebhookGeneratePdfResponse> => {
  
  const res = await fetch(getGetWebhookGeneratePdfUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookGeneratePdfResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookGeneratePdfResponse
}



/**
 * Processa todos os pedidos no status 'ready_for_delivery' para enviar emails de entrega aos clientes com links para download dos PDFs finais. ApÃ³s o envio bem-sucedido do email, atualiza o status do pedido para 'delivered' e notifica a equipe via Telegram sobre a entrega realizada.
 * @summary Entregar PDFs dos livros personalizados aos clientes
 */
export type getWebhookDeliverPdfResponse200 = {
  data: GetWebhookDeliverPdf200
  status: 200
}

export type getWebhookDeliverPdfResponse500 = {
  data: GetWebhookDeliverPdf500
  status: 500
}
    
export type getWebhookDeliverPdfResponseComposite = getWebhookDeliverPdfResponse200 | getWebhookDeliverPdfResponse500;
    
export type getWebhookDeliverPdfResponse = getWebhookDeliverPdfResponseComposite & {
  headers: Headers;
}

export const getGetWebhookDeliverPdfUrl = () => {


  

  return `/webhook/deliver-pdf`
}

export const getWebhookDeliverPdf = async ( options?: RequestInit): Promise<getWebhookDeliverPdfResponse> => {
  
  const res = await fetch(getGetWebhookDeliverPdfUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookDeliverPdfResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookDeliverPdfResponse
}
