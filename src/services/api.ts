/**
 * Generated by orval v7.6.0 🍺
 * Do not edit manually.
 * TrinityKitWP API
 * API para gerenciamento de posts, pedidos personalizados e formulários de contato no WordPress
 * OpenAPI spec version: 1.0.0
 */
import type {
  GetConfigs200,
  GetConfigs401,
  GetOrdersBookDetails200,
  GetOrdersBookDetails404,
  GetOrdersBookDetails500,
  GetOrdersCheckCoupon200,
  GetOrdersCheckCoupon400,
  GetOrdersCheckCoupon404,
  GetOrdersCheckCouponParams,
  GetOrdersOrderIdPaymentStatus200,
  GetOrdersOrderIdPaymentStatus404,
  GetPostSlug200,
  GetPostSlug400,
  GetPostSlug401,
  GetPostSlug404,
  GetPostSlugs200,
  GetPostSlugs401,
  GetPostSlugsParams,
  GetWebhookCheckFaceswap200,
  GetWebhookCheckFaceswap500,
  GetWebhookDeliverPdf200,
  GetWebhookDeliverPdf500,
  GetWebhookGeneratePdf200,
  GetWebhookGeneratePdf500,
  GetWebhookGenerateTextAssets200,
  GetWebhookGenerateTextAssets500,
  GetWebhookInitiateFaceswap200,
  GetWebhookInitiateFaceswap500,
  GetWebhookMergeAssets200,
  GetWebhookMergeAssets500,
  GetWebhookSendThanks200,
  GetWebhookSendThanks500,
  PostContactFormSubmit200,
  PostContactFormSubmit400,
  PostContactFormSubmit401,
  PostContactFormSubmit500,
  PostContactFormSubmitBody,
  PostOrders201,
  PostOrders400,
  PostOrders401,
  PostOrders500,
  PostOrdersBody,
  PostOrdersOrderIdPix200,
  PostOrdersOrderIdPix500,
  PostWebhookPaymentConfirm200,
  PostWebhookPaymentConfirm400,
  PostWebhookPaymentConfirm404,
  PostWebhookPaymentConfirmBody
} from './model';

/**
 * Retorna as configurações básicas do site WordPress
 * @summary Obter configurações do site
 */
export type getConfigsResponse200 = {
  data: GetConfigs200
  status: 200
}

export type getConfigsResponse401 = {
  data: GetConfigs401
  status: 401
}
    
export type getConfigsResponseComposite = getConfigsResponse200 | getConfigsResponse401;
    
export type getConfigsResponse = getConfigsResponseComposite & {
  headers: Headers;
}

export const getGetConfigsUrl = () => {


  

  return `/configs`
}

export const getConfigs = async ( options?: RequestInit): Promise<getConfigsResponse> => {
  
  const res = await fetch(getGetConfigsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getConfigsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getConfigsResponse
}



/**
 * Cria um novo registro de contato no WordPress com suporte para upload de arquivos. Todos os campos são obrigatórios exceto o arquivo anexo.
 * @summary Enviar formulário de contato
 */
export type postContactFormSubmitResponse200 = {
  data: PostContactFormSubmit200
  status: 200
}

export type postContactFormSubmitResponse400 = {
  data: PostContactFormSubmit400
  status: 400
}

export type postContactFormSubmitResponse401 = {
  data: PostContactFormSubmit401
  status: 401
}

export type postContactFormSubmitResponse500 = {
  data: PostContactFormSubmit500
  status: 500
}
    
export type postContactFormSubmitResponseComposite = postContactFormSubmitResponse200 | postContactFormSubmitResponse400 | postContactFormSubmitResponse401 | postContactFormSubmitResponse500;
    
export type postContactFormSubmitResponse = postContactFormSubmitResponseComposite & {
  headers: Headers;
}

export const getPostContactFormSubmitUrl = () => {


  

  return `/contact-form/submit`
}

export const postContactFormSubmit = async (postContactFormSubmitBody: PostContactFormSubmitBody, options?: RequestInit): Promise<postContactFormSubmitResponse> => {
    const formData = new FormData();
formData.append('name', postContactFormSubmitBody.name)
formData.append('email', postContactFormSubmitBody.email)
formData.append('phone', postContactFormSubmitBody.phone)
if(postContactFormSubmitBody.linkedin !== undefined) {
 formData.append('linkedin', postContactFormSubmitBody.linkedin)
 }
formData.append('message', postContactFormSubmitBody.message)
formData.append('tag', postContactFormSubmitBody.tag)
if(postContactFormSubmitBody.attachment !== undefined) {
 formData.append('attachment', postContactFormSubmitBody.attachment)
 }

  const res = await fetch(getPostContactFormSubmitUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postContactFormSubmitResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postContactFormSubmitResponse
}



/**
 * Retorna uma lista de posts publicados com seus detalhes. Pode ser limitado por quantidade ou paginado.
 * @summary Listar posts
 */
export type getPostSlugsResponse200 = {
  data: GetPostSlugs200
  status: 200
}

export type getPostSlugsResponse401 = {
  data: GetPostSlugs401
  status: 401
}
    
export type getPostSlugsResponseComposite = getPostSlugsResponse200 | getPostSlugsResponse401;
    
export type getPostSlugsResponse = getPostSlugsResponseComposite & {
  headers: Headers;
}

export const getGetPostSlugsUrl = (params?: GetPostSlugsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/post-slugs?${stringifiedParams}` : `/post-slugs`
}

export const getPostSlugs = async (params?: GetPostSlugsParams, options?: RequestInit): Promise<getPostSlugsResponse> => {
  
  const res = await fetch(getGetPostSlugsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getPostSlugsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getPostSlugsResponse
}



/**
 * Retorna os detalhes de um post específico usando seu slug
 * @summary Obter post por slug
 */
export type getPostSlugResponse200 = {
  data: GetPostSlug200
  status: 200
}

export type getPostSlugResponse400 = {
  data: GetPostSlug400
  status: 400
}

export type getPostSlugResponse401 = {
  data: GetPostSlug401
  status: 401
}

export type getPostSlugResponse404 = {
  data: GetPostSlug404
  status: 404
}
    
export type getPostSlugResponseComposite = getPostSlugResponse200 | getPostSlugResponse400 | getPostSlugResponse401 | getPostSlugResponse404;
    
export type getPostSlugResponse = getPostSlugResponseComposite & {
  headers: Headers;
}

export const getGetPostSlugUrl = (slug: string,) => {


  

  return `/post/${slug}`
}

export const getPostSlug = async (slug: string, options?: RequestInit): Promise<getPostSlugResponse> => {
  
  const res = await fetch(getGetPostSlugUrl(slug),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getPostSlugResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getPostSlugResponse
}



/**
 * Cria um novo pedido personalizado para uma criança
 * @summary Criar novo pedido
 */
export type postOrdersResponse201 = {
  data: PostOrders201
  status: 201
}

export type postOrdersResponse400 = {
  data: PostOrders400
  status: 400
}

export type postOrdersResponse401 = {
  data: PostOrders401
  status: 401
}

export type postOrdersResponse500 = {
  data: PostOrders500
  status: 500
}
    
export type postOrdersResponseComposite = postOrdersResponse201 | postOrdersResponse400 | postOrdersResponse401 | postOrdersResponse500;
    
export type postOrdersResponse = postOrdersResponseComposite & {
  headers: Headers;
}

export const getPostOrdersUrl = () => {


  

  return `/orders`
}

export const postOrders = async (postOrdersBody: PostOrdersBody, options?: RequestInit): Promise<postOrdersResponse> => {
    const formData = new FormData();
if(postOrdersBody.coupon !== undefined) {
 formData.append('coupon', postOrdersBody.coupon)
 }
formData.append('childName', postOrdersBody.childName)
formData.append('childAge', postOrdersBody.childAge.toString())
formData.append('childGender', postOrdersBody.childGender)
formData.append('skinTone', postOrdersBody.skinTone)
formData.append('parentName', postOrdersBody.parentName)
formData.append('email', postOrdersBody.email)
formData.append('phone', postOrdersBody.phone)
formData.append('photo', postOrdersBody.photo)

  const res = await fetch(getPostOrdersUrl(),
  {      
    ...options,
    method: 'POST'
    ,
    body: 
      formData,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postOrdersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postOrdersResponse
}



/**
 * Retorna informações básicas do livro mais recente publicado no sistema, incluindo ID, nome e preço. Este endpoint não requer autenticação e busca automaticamente o livro mais recente baseado na data de publicação.
 * @summary Obter detalhes do livro mais recente
 */
export type getOrdersBookDetailsResponse200 = {
  data: GetOrdersBookDetails200
  status: 200
}

export type getOrdersBookDetailsResponse404 = {
  data: GetOrdersBookDetails404
  status: 404
}

export type getOrdersBookDetailsResponse500 = {
  data: GetOrdersBookDetails500
  status: 500
}
    
export type getOrdersBookDetailsResponseComposite = getOrdersBookDetailsResponse200 | getOrdersBookDetailsResponse404 | getOrdersBookDetailsResponse500;
    
export type getOrdersBookDetailsResponse = getOrdersBookDetailsResponseComposite & {
  headers: Headers;
}

export const getGetOrdersBookDetailsUrl = () => {


  

  return `/orders/book-details`
}

export const getOrdersBookDetails = async ( options?: RequestInit): Promise<getOrdersBookDetailsResponse> => {
  
  const res = await fetch(getGetOrdersBookDetailsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOrdersBookDetailsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getOrdersBookDetailsResponse
}



/**
 * Cria um pagamento PIX para um pedido existente usando a API do Asaas
 * @summary Criar pagamento PIX para um pedido
 */
export type postOrdersOrderIdPixResponse200 = {
  data: PostOrdersOrderIdPix200
  status: 200
}

export type postOrdersOrderIdPixResponse500 = {
  data: PostOrdersOrderIdPix500
  status: 500
}
    
export type postOrdersOrderIdPixResponseComposite = postOrdersOrderIdPixResponse200 | postOrdersOrderIdPixResponse500;
    
export type postOrdersOrderIdPixResponse = postOrdersOrderIdPixResponseComposite & {
  headers: Headers;
}

export const getPostOrdersOrderIdPixUrl = (orderId: number,) => {


  

  return `/orders/${orderId}/pix`
}

export const postOrdersOrderIdPix = async (orderId: number, options?: RequestInit): Promise<postOrdersOrderIdPixResponse> => {
  
  const res = await fetch(getPostOrdersOrderIdPixUrl(orderId),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postOrdersOrderIdPixResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postOrdersOrderIdPixResponse
}



/**
 * Valida um cupom para um pedido e retorna o preço atualizado
 * @summary Validar cupom e retornar preço atualizado
 */
export type getOrdersCheckCouponResponse200 = {
  data: GetOrdersCheckCoupon200
  status: 200
}

export type getOrdersCheckCouponResponse400 = {
  data: GetOrdersCheckCoupon400
  status: 400
}

export type getOrdersCheckCouponResponse404 = {
  data: GetOrdersCheckCoupon404
  status: 404
}
    
export type getOrdersCheckCouponResponseComposite = getOrdersCheckCouponResponse200 | getOrdersCheckCouponResponse400 | getOrdersCheckCouponResponse404;
    
export type getOrdersCheckCouponResponse = getOrdersCheckCouponResponseComposite & {
  headers: Headers;
}

export const getGetOrdersCheckCouponUrl = (params: GetOrdersCheckCouponParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/orders/check-coupon?${stringifiedParams}` : `/orders/check-coupon`
}

export const getOrdersCheckCoupon = async (params: GetOrdersCheckCouponParams, options?: RequestInit): Promise<getOrdersCheckCouponResponse> => {
  
  const res = await fetch(getGetOrdersCheckCouponUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOrdersCheckCouponResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getOrdersCheckCouponResponse
}



/**
 * Endpoint para receber notificações de confirmação de pagamento do Asaas. Atualiza o status do pedido para pago e registra os dados da transação.
 * @summary Webhook de confirmação de pagamento
 */
export type postWebhookPaymentConfirmResponse200 = {
  data: PostWebhookPaymentConfirm200
  status: 200
}

export type postWebhookPaymentConfirmResponse400 = {
  data: PostWebhookPaymentConfirm400
  status: 400
}

export type postWebhookPaymentConfirmResponse404 = {
  data: PostWebhookPaymentConfirm404
  status: 404
}
    
export type postWebhookPaymentConfirmResponseComposite = postWebhookPaymentConfirmResponse200 | postWebhookPaymentConfirmResponse400 | postWebhookPaymentConfirmResponse404;
    
export type postWebhookPaymentConfirmResponse = postWebhookPaymentConfirmResponseComposite & {
  headers: Headers;
}

export const getPostWebhookPaymentConfirmUrl = () => {


  

  return `/webhook/payment-confirm`
}

export const postWebhookPaymentConfirm = async (postWebhookPaymentConfirmBody: PostWebhookPaymentConfirmBody, options?: RequestInit): Promise<postWebhookPaymentConfirmResponse> => {
  
  const res = await fetch(getPostWebhookPaymentConfirmUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      postWebhookPaymentConfirmBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postWebhookPaymentConfirmResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postWebhookPaymentConfirmResponse
}



/**
 * Verifica se um pedido específico já foi pago
 * @summary Verificar status do pagamento
 */
export type getOrdersOrderIdPaymentStatusResponse200 = {
  data: GetOrdersOrderIdPaymentStatus200
  status: 200
}

export type getOrdersOrderIdPaymentStatusResponse404 = {
  data: GetOrdersOrderIdPaymentStatus404
  status: 404
}
    
export type getOrdersOrderIdPaymentStatusResponseComposite = getOrdersOrderIdPaymentStatusResponse200 | getOrdersOrderIdPaymentStatusResponse404;
    
export type getOrdersOrderIdPaymentStatusResponse = getOrdersOrderIdPaymentStatusResponseComposite & {
  headers: Headers;
}

export const getGetOrdersOrderIdPaymentStatusUrl = (orderId: number,) => {


  

  return `/orders/${orderId}/payment-status`
}

export const getOrdersOrderIdPaymentStatus = async (orderId: number, options?: RequestInit): Promise<getOrdersOrderIdPaymentStatusResponse> => {
  
  const res = await fetch(getGetOrdersOrderIdPaymentStatusUrl(orderId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getOrdersOrderIdPaymentStatusResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getOrdersOrderIdPaymentStatusResponse
}



/**
 * Endpoint que verifica pedidos com status 'paid', envia emails de agradecimento e atualiza o status para 'thanked'
 * @summary Webhook para envio de emails de agradecimento
 */
export type getWebhookSendThanksResponse200 = {
  data: GetWebhookSendThanks200
  status: 200
}

export type getWebhookSendThanksResponse500 = {
  data: GetWebhookSendThanks500
  status: 500
}
    
export type getWebhookSendThanksResponseComposite = getWebhookSendThanksResponse200 | getWebhookSendThanksResponse500;
    
export type getWebhookSendThanksResponse = getWebhookSendThanksResponseComposite & {
  headers: Headers;
}

export const getGetWebhookSendThanksUrl = () => {


  

  return `/webhook/send-thanks`
}

export const getWebhookSendThanks = async ( options?: RequestInit): Promise<getWebhookSendThanksResponse> => {
  
  const res = await fetch(getGetWebhookSendThanksUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookSendThanksResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookSendThanksResponse
}



/**
 * Processa todos os pedidos no status 'thanked' para gerar textos personalizados usando Deepseek API
 * @summary Gerar textos personalizados em lote
 */
export type getWebhookGenerateTextAssetsResponse200 = {
  data: GetWebhookGenerateTextAssets200
  status: 200
}

export type getWebhookGenerateTextAssetsResponse500 = {
  data: GetWebhookGenerateTextAssets500
  status: 500
}
    
export type getWebhookGenerateTextAssetsResponseComposite = getWebhookGenerateTextAssetsResponse200 | getWebhookGenerateTextAssetsResponse500;
    
export type getWebhookGenerateTextAssetsResponse = getWebhookGenerateTextAssetsResponseComposite & {
  headers: Headers;
}

export const getGetWebhookGenerateTextAssetsUrl = () => {


  

  return `/webhook/generate-text-assets`
}

export const getWebhookGenerateTextAssets = async ( options?: RequestInit): Promise<getWebhookGenerateTextAssetsResponse> => {
  
  const res = await fetch(getGetWebhookGenerateTextAssetsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookGenerateTextAssetsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookGenerateTextAssetsResponse
}



/**
 * Processa todos os pedidos no status 'created_assets_text' que ainda não tiveram o face swap iniciado. Para cada página do livro, inicia o processo de face swap na API externa e salva os IDs das tarefas retornadas.
 * @summary Iniciar processo de face swap em lote
 */
export type getWebhookInitiateFaceswapResponse200 = {
  data: GetWebhookInitiateFaceswap200
  status: 200
}

export type getWebhookInitiateFaceswapResponse500 = {
  data: GetWebhookInitiateFaceswap500
  status: 500
}
    
export type getWebhookInitiateFaceswapResponseComposite = getWebhookInitiateFaceswapResponse200 | getWebhookInitiateFaceswapResponse500;
    
export type getWebhookInitiateFaceswapResponse = getWebhookInitiateFaceswapResponseComposite & {
  headers: Headers;
}

export const getGetWebhookInitiateFaceswapUrl = () => {


  

  return `/webhook/initiate-faceswap`
}

export const getWebhookInitiateFaceswap = async ( options?: RequestInit): Promise<getWebhookInitiateFaceswapResponse> => {
  
  const res = await fetch(getGetWebhookInitiateFaceswapUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookInitiateFaceswapResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookInitiateFaceswapResponse
}



/**
 * Processa todos os pedidos no status 'created_assets_text' que já tiveram o face swap iniciado (face_swap_initiated = true). Verifica o status das tarefas na API externa e processa as imagens que estão prontas, salvando-as no WordPress e atualizando o status do pedido quando todas as páginas estiverem concluídas.
 * @summary Verificar status do face swap e processar imagens prontas
 */
export type getWebhookCheckFaceswapResponse200 = {
  data: GetWebhookCheckFaceswap200
  status: 200
}

export type getWebhookCheckFaceswapResponse500 = {
  data: GetWebhookCheckFaceswap500
  status: 500
}
    
export type getWebhookCheckFaceswapResponseComposite = getWebhookCheckFaceswapResponse200 | getWebhookCheckFaceswapResponse500;
    
export type getWebhookCheckFaceswapResponse = getWebhookCheckFaceswapResponseComposite & {
  headers: Headers;
}

export const getGetWebhookCheckFaceswapUrl = () => {


  

  return `/webhook/check-faceswap`
}

export const getWebhookCheckFaceswap = async ( options?: RequestInit): Promise<getWebhookCheckFaceswapResponse> => {
  
  const res = await fetch(getGetWebhookCheckFaceswapUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookCheckFaceswapResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookCheckFaceswapResponse
}



/**
 * Processa todos os pedidos no status 'created_assets_illustration' para combinar os textos personalizados com as ilustrações processadas. Gera as páginas finais do livro com texto sobreposto nas imagens na metade direita, usando fonte branca com sombra para boa legibilidade.
 * @summary Combinar textos e ilustrações em lote
 */
export type getWebhookMergeAssetsResponse200 = {
  data: GetWebhookMergeAssets200
  status: 200
}

export type getWebhookMergeAssetsResponse500 = {
  data: GetWebhookMergeAssets500
  status: 500
}
    
export type getWebhookMergeAssetsResponseComposite = getWebhookMergeAssetsResponse200 | getWebhookMergeAssetsResponse500;
    
export type getWebhookMergeAssetsResponse = getWebhookMergeAssetsResponseComposite & {
  headers: Headers;
}

export const getGetWebhookMergeAssetsUrl = () => {


  

  return `/webhook/merge-assets`
}

export const getWebhookMergeAssets = async ( options?: RequestInit): Promise<getWebhookMergeAssetsResponse> => {
  
  const res = await fetch(getGetWebhookMergeAssetsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookMergeAssetsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookMergeAssetsResponse
}



/**
 * Processa todos os pedidos no status 'created_assets_merge' para gerar PDFs completos dos livros personalizados. Coleta todas as imagens finais das páginas (final_page_with_text) e cria um PDF profissional com todas as páginas do livro na ordem correta. Após a geração bem-sucedida, atualiza o status do pedido para 'ready_for_delivery'.
 * @summary Gerar PDFs dos livros personalizados em lote
 */
export type getWebhookGeneratePdfResponse200 = {
  data: GetWebhookGeneratePdf200
  status: 200
}

export type getWebhookGeneratePdfResponse500 = {
  data: GetWebhookGeneratePdf500
  status: 500
}
    
export type getWebhookGeneratePdfResponseComposite = getWebhookGeneratePdfResponse200 | getWebhookGeneratePdfResponse500;
    
export type getWebhookGeneratePdfResponse = getWebhookGeneratePdfResponseComposite & {
  headers: Headers;
}

export const getGetWebhookGeneratePdfUrl = () => {


  

  return `/webhook/generate-pdf`
}

export const getWebhookGeneratePdf = async ( options?: RequestInit): Promise<getWebhookGeneratePdfResponse> => {
  
  const res = await fetch(getGetWebhookGeneratePdfUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookGeneratePdfResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookGeneratePdfResponse
}



/**
 * Processa todos os pedidos no status 'ready_for_delivery' para enviar emails de entrega aos clientes com links para download dos PDFs finais. Após o envio bem-sucedido do email, atualiza o status do pedido para 'delivered' e notifica a equipe via Telegram sobre a entrega realizada.
 * @summary Entregar PDFs dos livros personalizados aos clientes
 */
export type getWebhookDeliverPdfResponse200 = {
  data: GetWebhookDeliverPdf200
  status: 200
}

export type getWebhookDeliverPdfResponse500 = {
  data: GetWebhookDeliverPdf500
  status: 500
}
    
export type getWebhookDeliverPdfResponseComposite = getWebhookDeliverPdfResponse200 | getWebhookDeliverPdfResponse500;
    
export type getWebhookDeliverPdfResponse = getWebhookDeliverPdfResponseComposite & {
  headers: Headers;
}

export const getGetWebhookDeliverPdfUrl = () => {


  

  return `/webhook/deliver-pdf`
}

export const getWebhookDeliverPdf = async ( options?: RequestInit): Promise<getWebhookDeliverPdfResponse> => {
  
  const res = await fetch(getGetWebhookDeliverPdfUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getWebhookDeliverPdfResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getWebhookDeliverPdfResponse
}
